# Logstash Configuration for Casino Platform
# Processes logs from all microservices

input {
  # TCP input for Logback socket appender
  tcp {
    port => 5000
    codec => json_lines
    tags => ["microservice"]
  }

  # File input for application logs
  file {
    path => "/var/log/casino/**/*.log"
    start_position => "beginning"
    codec => multiline {
      pattern => "^%{TIMESTAMP_ISO8601}"
      negate => true
      what => "previous"
    }
    tags => ["file"]
  }

  # Beats input for container logs
  beats {
    port => 5044
    tags => ["container"]
  }
}

filter {
  # Parse JSON logs
  if [message] =~ /^\{/ {
    json {
      source => "message"
    }
  }

  # Parse Java stack traces
  if [level] == "ERROR" {
    grok {
      match => {
        "message" => "(?<stacktrace>(?m).*Exception.*)"
      }
    }
  }

  # Extract service name from logger
  if [logger_name] {
    grok {
      match => {
        "logger_name" => "com\.casino\.(?<service>[^.]+)"
      }
    }
  }

  # Add geo-location for IP addresses
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geo"
    }
  }

  # Parse HTTP access logs
  if [type] == "access" {
    grok {
      match => {
        "message" => '%{IPORHOST:client_ip} - - \[%{HTTPDATE:timestamp}\] "%{WORD:http_method} %{URIPATHPARAM:request} HTTP/%{NUMBER:http_version}" %{NUMBER:response_code} %{NUMBER:bytes}'
      }
    }

    date {
      match => ["timestamp", "dd/MMM/yyyy:HH:mm:ss Z"]
      target => "@timestamp"
    }

    mutate {
      convert => {
        "response_code" => "integer"
        "bytes" => "integer"
      }
    }
  }

  # Enrich payment logs
  if [service] == "payment" {
    if [transaction_id] {
      mutate {
        add_tag => ["payment_transaction"]
      }
    }
    if [payment_provider] {
      mutate {
        add_field => {
          "[@metadata][payment_provider]" => "%{payment_provider}"
        }
      }
    }
  }

  # Enrich game logs
  if [service] == "game" {
    if [game_type] {
      mutate {
        add_tag => ["game_play"]
        add_field => {
          "[@metadata][game_type]" => "%{game_type}"
        }
      }
    }
  }

  # Flag security events
  if [event_type] =~ /login|logout|failed_auth|kyc|aml/ {
    mutate {
      add_tag => ["security"]
    }
  }

  # Flag error events
  if [level] in ["ERROR", "FATAL"] {
    mutate {
      add_tag => ["error"]
    }
  }

  # Add environment
  mutate {
    add_field => {
      "environment" => "${ENVIRONMENT:production}"
    }
  }

  # Remove unnecessary fields
  mutate {
    remove_field => ["beat", "host", "prospector", "input", "offset"]
  }
}

output {
  # Send to Elasticsearch
  elasticsearch {
    hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
    index => "casino-logs-%{service}-%{+YYYY.MM.dd}"
    user => "${ELASTICSEARCH_USER:elastic}"
    password => "${ELASTICSEARCH_PASSWORD:changeme}"
  }

  # Error logs to separate index
  if "error" in [tags] {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
      index => "casino-errors-%{+YYYY.MM.dd}"
      user => "${ELASTICSEARCH_USER:elastic}"
      password => "${ELASTICSEARCH_PASSWORD:changeme}"
    }
  }

  # Security logs to separate index
  if "security" in [tags] {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
      index => "casino-security-%{+YYYY.MM.dd}"
      user => "${ELASTICSEARCH_USER:elastic}"
      password => "${ELASTICSEARCH_PASSWORD:changeme}"
    }
  }

  # Payment logs to separate index
  if "payment_transaction" in [tags] {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
      index => "casino-payments-%{+YYYY.MM.dd}"
      user => "${ELASTICSEARCH_USER:elastic}"
      password => "${ELASTICSEARCH_PASSWORD:changeme}"
    }
  }

  # Debug output (can be removed in production)
  if "${LOG_DEBUG:false}" == "true" {
    stdout {
      codec => rubydebug
    }
  }
}
